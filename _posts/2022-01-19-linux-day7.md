---
title: "[linux] Day 7"
excerpt: "Shell 그리고 Directory"

categories:
    - linux
tags:
    -Blog, linux, 비전공자, 리눅스

toc: true
toc_sticky: true
published: true

date: 2022-01-19
---

# Day 7

## <span style="color:Blue"> 1. Process </span>

Storage : sd,hdd같은 것들
Memory : Ram
Processor :Cpu

메모리와 스토리지의 공통점 = 정보를 저장한다.
왜 그럼 다른 것으로 분류해두었는가? 

스토리지 : 저렴한 가격, 큰 저장용량, 속도가 엄청나게 느림 
메모리 : 비싼 가격, 적은 저장용량, cpu가 동작할 때 엄청나게 빠르게 동작함. 

cpu는 빠르기 때문에 느린 스토리지를 사용할 수 없어서 빠른 메모리에 필요한 프로그램을 적재하여 사용하고, 사용하지 않는 것들은 스토리지에 저장되어 있다. 

프로세스 : 사용자가 입력하는 명령어(Command) = /bin or /sbin 의 디렉토리에 파일의 형태로 저장되어 있으며, storage에 저장되어있다. 즉, 파일의 형태로 저장되어 있는 것들은 프로그램이라고 함. 여기서 사용하는 프로그램들이 실행되면 메모리에 적재되는데 cpu에 의해 처리되는 상태의 것들을 프로세스라고 이야기한다. / 즉, 프로세스를 처리하는 것들을 프로세서라고 이야기함. 

#### 프로그램 관찰하고 대응하는 방법 
프로세스 리스트 보는 법 
~~~vim
$ ps (process list)
or
$ ps aux
~~~
ps 는 지금 화면에 띄워지는 프로그램들, ps aux는 백그라운드에서 돌아가는 모든 것들을 확인 할 수 있음

내가 원하는 프로세스가 어떻게 돌아가는지  확인하고 싶다면? 
~~~vim
$ ps aux | terminal
~~~
이렇게 검색하면 되는데 여기서 | = 저저번 시간에 배웠던 파이프 내용이 연결된다. 
즉, ps aux의 결과물 중, 내가 원하는 terminal이라는 이름을 포함하고 있는 것들을 연결시켜서 보여주는 것

결과물을 볼 때, PID라는 식별자는 Process ID를 이야기한다. 이 식별자를 통해 프로그램을 강제로 종료시키는 것도 가능한데 이때 사용하는 명령어는 <span style="color:yellow"> Kill </span> 을 활용하여 가능하다. 예를들어 PID가 1234라고 한다면 
~~~vim
$ sudo kill 1234
~~~
를 통해 삭제할 수 있다는 것이다. 즉, kill을 통해 강제로 종료시킬 수 있다.

프로세스 리스트 보는 것 = top or htop (htop이 조금 더 화려하고 보기 편함) 

htop에 있는 항목들 바라보기. (약간 작업관리자 보는 것 같음)   
commnad = 어떤 명령어로 실행되고 있는지를 보여줌    
RES = 실제적인 메모리 사용량    
MeM = 물리적인 메모리의 크기   

<p allign ="left"><img src = "image/cpu core.png" width = 100></p>

여기서 숫자들은 각각의 코어를 이야기해줌. 막대는 각각의 코어가 얼마나 바쁜지를 보여줌. 
load = 부화 (얼마나 바쁜가?) / average = 평균   
즉 cpu의 점유율에 대해 알려주는 것, 첫 번째 자리는 1분, 두 번째는 5분, 세 번째는 15분의 cpu노동의 평균치를 보여줌.(사실 잘 모르고 넘어가도 된다고 함... 그리고 나도 이해 못하겠음...)   
코어의 갯수가 몇개인지에 따라 숫자의 의미가 달라질 수 있다. 

## <span style="color:blue"> 2. File </span>
### <span style="color:skyblue"> locate, Find </span>
파일은 두가지 용도로 사용이 됨 : 1. 데이터 보관 , 2. 해야할 일에 대한 명령을 보관하고 있는 실행파일   
파일을 찾는 가장 빠른 명령 : <span style="color:yellow"> locate   </span>    

Locate 가 가지고 있는 특징 : 검색할 때 디렉토리를 뒤지는 것이 아니라, 데이터 베이스를 통해 찾음. 즉, 컴퓨터 안에 저장되어있는 파일들에 대한 데이터베이스를 통해 파일을 찾기 때문에 훨씬 더 빠르게 처리할 수 있음.    
locate가 사용하는 데이터베이스는 mlocate라고 부른다.
mlocate라는 데이터베이스 안에 있는 파일의 목록은 
~~~vim
$ up sudo updatedb
~~~
현재 이 컴퓨터에 있는 파일들에 대한 여러가지 정보들이 updatedb 명령어를 통해 진행되며, 많은 리눅스 시스템에서 하루에 한 번씩 정기적으로 처리하게 되어있음. 

또 다른 명령어 : <span style="color:yellow">find </span>  
find의 locate와는 다르게 디렉토리를 통해 찾는 것이기 때문에, locate보다 성능상으로는 별로일 수 있지만, find의 경우 지금 가지고 오는 것이기 때문에 파일을 찾는 것에 있어서는 거의 마스터링 툴이라고 보면 됨. 
~~~vim
$ find / : 루트 디렉토리에서 부터 찾겠다.
$ find . : 현재 디렉토리부터 하위 디렉토리까지 찾겠다.
~~~
만약, 텍스트 파일만 검색하고 싶다면, 
~~~vim
$ find -name *.txt
~~~
라고 검색하는 과정을 통해, 내 컴퓨터에 있는 모든 디렉토리를 뒤져서 txt라는 이름이 있는 파일을 있는지를 찾음. 하지만, 과정중에 permission denide 라고 나오는 경우가 있는데 이 경우는 sudo 명령어를 사용해서 찾을 수 있음. 

만약 나의 홈 디렉토리 밑에서 찾고 싶다면, sudo는 필요 없을 것. 
~~~vim
$ find ~ -name *.txt
~~~
(~) 는 나의 홈 디렉토리에서 부터 찾음을 이야기하는 것이기 때문에 홈 디렉토리부터 그 밑에 부분들 까지 해서 .txt라는 이름을 가진 파일을 찾아줌을 이야기함. find라는 명령은 상당히 복잡하기 때문에 몇가지만 눈여겨 볼 것.   

파일의 확장자 지정도 가능. <span style="color:yellow"> -type f </span>    
<br/>
~~~vim
$ find . type f -name "abc.txt" -exec rm -f {} \;
~~~

천천히 설명하자면, 현재 내가 머물고 있는 디렉토리에서, 디렉토리가 아닌 파일에서, 이름이 abc인 것을 찾는다. 그 후, exec = excute 즉 실행시킬건데, -f 묻지도 따지지도 말고 rm(remove)해라. {명령을 통해 검색한 파일의 이름이 위치하게 되는 곳}    
*즉, 내가 현재 위치한 곳에서 내가 검색하고자 하는 파일을 찾아서 이유 묻지도 말고 삭제해라~ 이런 뜻임.*

### <span style="color:skyblue"> whereis, $PATH </span>
whereis = 내가 원하는 실행 파일을 찾아주는 명령어   
$PATH = 변수 / 명령어가 어디에 위치하고 있는가 저장해두는 것 / <span style="color: green">  환경변수 </span> 


~~~vim
:~$ echo $PATH
/opt/gradle/bin:/opt/maven/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/go/bin:/usr/local/nvm/versions/node/v12.14.1/bin:/usr/local/rvm/bin:/google/go_appengine:/google/google_appengine:/google/migrate/anthos/:/home/top9712/.gems/bin:/usr/local/rvm/bin:/home/top9712/gopath/bin:/google/gopath/bin:/google/flutter/bin
~~~
이렇게 나오는데, 여기서 사용한 echo $PATH 를 통해 $PATH라는 변수에 담겨있는 데이터들이 화면에 출력이 된 결과이다. 이 정보들 사이에 들어가았는 :는 정보를 구별해주는 것이고, 각각의 /로 나눠져있는 것은 경로를 이야기한다. $PATH 변수는 리눅스, 혹은 유닉스 계열에서 PATH변수를 기본적으로 가지고 있음을 알 수 있다. 

<span style="color:yellow"> 명령어들이 작동하는 방식은 우리가 명령어를 입력해서 나온 결과물에 대해서 $PATH라는 변수에 담겨있는 디렉토리에서 우리가 작성한 명령어가 존재하는지 차례대로 확인하기 시작하며, 작성한 명령어가 확인되면 그 명령어를 실행하는 방식으로 작동되는 것이다.    
명령어 작성 -> $PATH에서 디렉토리마다 검색 -> 확인 -> 명령어 실행 </span> 

$PATH값은 변경할 수 있고, 변경한 path값에 대해 우리가 원하는 디렉토리를 $PATH에 넣어둔다면, 그 디렉토리도 명령어로 사용할 수 있다. 

## <span style="color:blue"> 3. Background </span>
터미널에서도 멀티태스킹이 가능한데 예를 들어 nano, 즉 편집기를 편집하다 터미널로 돌아온다는 것을 해보자.

~~~vim
$ nano 
~~~
를 입력하면, 편집기가 나오는데, 여기서 편집하는 과정에서 터미널을 사용하고 싶다면 
Ctntrol + Z 를 누르면 다시 터미널 환경으로 돌아올 수 있다. 이때, 터미널에서
~~~vim
nano
Use "fg" to return to nano.

[1]+  Stopped                 nano
~~~
이렇게 나오는데 위에 적힌 설명은 nano라는 프로그램이 백그라운드에서 실행되고 있음을 의미한다.   
만약 다시 편집기 모드로 돌아가고 싶다면,
~~~vim
$ fg
~~~
를 입력해서 돌아갈 수 있다. 또한, 백그라운드에서 실행되고 있는 프로그램들을 확인하고싶다면, 
~~~vim
$ jobs
[1]   Stopped                 nano
[2]-  Stopped                 vim
[3]+  Stopped                 nano
~~~
jobs 라는 명령어를 통해 확인할 수 있다. 여기서 나오는 (+)는 지금 백그라운드로 돌아가는 명령어 fg를 입력했을 때 활성화되는 프로그램을 말하는 것이고, (-)는 백그라운드에서 돌아가는 (+)상태의 프로그램이 종료되고 난 후에, 활성화 될 순서라는 것을 이야기해준다.   
<span style="color:darkgray"> *Q.그럼 무조건 저 순서대로 해야되는건가요?* </span> 
No 만약 [2]번에 활성화된 vim을 실행시키고 싶다면
~~~vim
$ fg %2
~~~
라고 명령어를 입력시킨다면, [2]에 활성화 되어있는 것을 불러올 수 있고, 활성화 된 vim을 종료하고 싶다면, 
~~~vim
$ Kill %2
~~~
로 해주면 죽일 수 있다.    
kill로 하는 경우 일반적인 삭제이기 때문에 가끔 안 될 때가 있는데, 이런 경우에는 Kill -9 %4 라고 치면 Killed 라는 말이 나오며 종료되는 것을 확인할 수 있다.

만약 실행시킬 때 부터 프로그램을 백그라운드로 보내고 싶다면, <span style="color:yellow"> **&** </span> 표시를 통해 백그라운드로 보낼 수 있고, 백그라운드에서의 작업이 끝났다면 [Exit]이라는 말과 함께 끝났음을 확인할 수 있다. 

## <span style="color:Blue"> 정리해봅시다. </span>

오늘 배운 내용이 조금 복잡하기도 하고 많아서, 천천히 내가 이해한대로 정리해보자. 

- 일단 제일 첫 부분에서는 프로세스에 대해 이해하는 시간을 가졌다.    
프로세스는 스토리지에 저장되어있던 프로그램들을 메모리로 불러와 cpu를 거쳐서 실행되는 것들을 이야기한다.     
프로그램들이 메모리가 아닌 프로세스에 처음으로 저장되어있는 이유는, 스토리지는 용량이 크기 때문에 많은 것들을 저장하고 있을 수 있다. 하지만, 용량이 큰 만큼 처리하는 속도가 느리기 때문에 프로그램들을 사용하지 않을 때에는 스토리지에 저장하고 있다가, 사용하는 것들을 메모리로 옮겨 실행시키는데 이는 메모리의 용량이 작은 대신 프로그램을 실행시키는 속도가 스토리지보다 빠르기 때문이다. 

- 그럼 지금 돌아가고 있는 프로세스는 어떻게 확인하는가?    
현재 나의 화면에서 띄워지는 것들을 확인하기 위해서는 *ps* 명령어를 사용하면 되고, 백그라운드에서 돌아가는 것을 확인해보고 싶다면 *ps aux* 명령어를 사용하여 확인 할 수 있다. 프로세스는 각각의 아이디를 가지고 있기 때문에, 강제 종료도 가능한데, 종료를 위해서는 *kill*이라는 명령어를 사용한다. 
- 흔히 윈도우에서 사용하는 작업관리자의 역할처럼 보이는 것을 확인하기 위해 htop 혹은 top을 실행시킨다. 여기에서는 많은 정보를 얻을 수 있지만, 사실 코어를 설명하신 부분에서는 잘 이해가 안되기 때문에 나머지 강의들을 들으며 차차 이해해나가기로 했다.
- 이제 프로세스에 대해 알았으니 파일에 대해 알아보는 시간을 가졌다. 
파일을 찾는 방법에는 *find*와 *locate*이용하는 두가지 방법이 있다. 
- locate는 디렉토리가 아닌 데이터베이스를 통해 찾는 과정을 진행하기 때문에, 일의 처리 속도가 훨씬 빠르다. 
- find 는 일의 처리 속도가 locate에 비해서는 부족할 수 있지만, 디렉토리를 통해 찾는 과정을 하는 것으로 지금 당장의 파일을 가지고 오는 명령어기 때문에 파일을 찾는 명령어 중에서는 거의 마스터키와 같다고 한다. 
- 내가 원하는 실행 파일은 그럼 어떻게 찾는가? = whereis 이다.    
whereis는 내가 실행하고자하는 파일이 어디에 있는가?에 대한 경로를 보여주는 명령어이다. 이때 우리는 경로를 확인해 볼 수 있는데, 저번시간에 배웠던 디렉토리의 구조 부분의 내용도 조금 연결되어 나온다.    
또한, 오늘 수업 내용에서는 환경변수라는 내용이 처음으로 등장했는데, 환경변수란  프로세스가 컴퓨터에서 동작하는 방식에 영향을 미치는, 동적인 값들의 모임을 이야기한다. 즉, 환경변수인 $PATH는 명령어가 동작하는 방식에 영향을 미치는 변수들의 모임을 이야기한다고 이해했다. 우리는 이 $PATH를 직접 수정할 수 있는데 수정하는 과정을 통해 내가 원하는 경로를 설정하여 명령어를 실행시킬 수 있다.    
- Background? 멀티테스킹?   
윈도우나 os를 사용하다보면 우리는 흔히 멀티태스킹을 사용하는데, 리눅스에서도 가능하다. *Control+Z*를 통해서 실행시킬 수 있는데, 기존에 작업하던 것으로 돌아가고 싶다면 <mark style='background-color: #fff5b1'> fg</mark> 명령어를 통해 돌아갈 수 있고, 처음부터 백그라운드에서 실행시키고싶다면 <mark style='bcakground-color: #fff5b1'>&</mark>를 통해 실행시킬 수 있다. 여러개를 실행시켜 백그라운드에 여러가지의 파일들이 진행되고 있다면 fg %(번호)를 통해 이동할 수 있으며, 프로세스와 같이 kill 명령어를 통해 종료시킬 수 있다. 


-------
오늘 내용이 좀 많은데, 이제 리눅스 30번째 강의까지 다 들었다.   
리눅스 강의 끝나고는 다시 html, css로 돌아갈 생각인데, 얼른 끝내고 새로운 것들을 배워서 마니또 프로그램을 만들어보고 싶다. ㅎㅅㅎ 하나하나 천천히 이해해나가고 있으니 꾸준히 해보자 화이팅! 